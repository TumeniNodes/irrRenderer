        /**
         * Creates a new post-processing effect chain.
         * @return Pointer to the newly created chain.
         */
        irr::video::CPostProcessingEffectChain* createPostProcessingEffectChain();

        /**
         * Adds a new post processing effect into the chain
         * @param effectShader shader to use fur this effect
         * @param callback custom callback to use for this shader, if any
         * @return A pointer to the newly created post processing effect
         */
        irr::video::CPostProcessingEffect* createPostProcessingEffect(irr::video::SShaderSource &effectShader, irr::video::IShaderConstantSetCallBack* callback= new irr::video::IShaderDefaultPostProcessCallback);

        /**
         * Adds a new post processing effect into the chain using one of the included shaders
         * @param type type of the shader
         * @return A pointer to the newly created post processing effect
         */
        irr::video::CPostProcessingEffect* createPostProcessingEffect(irr::video::E_POSTPROCESSING_EFFECT type);

        /**
         * Enables/Disables post processing
         * @param enable enable or disable post processing
         */
        void enablePostProcessing(bool enable, irr::video::ECOLOR_FORMAT format= irr::video::ECF_A8R8G8B8);

        /**
         * Returns the root post-processing effect chain. Effects which don't belong to a specific chain are managed by a "root" chain.
         * @return Pointer to the root post-processing effect chain.
         */
        irr::video::CPostProcessingEffectChain* getRootPostProcessingEffectChain() const;

===============================================================================


irr::video::CPostProcessingEffectChain* irr::video::CRenderer::createPostProcessingEffectChain()
{
    irr::video::CPostProcessingEffectChain* chain= new irr::video::CPostProcessingEffectChain(this);
    LightMgr->addPostProcessingEffectChain(chain);
    return chain;
}

irr::video::CPostProcessingEffect* irr::video::CRenderer::createPostProcessingEffect(irr::video::SShaderSource &effectShader, irr::video::IShaderConstantSetCallBack* callback)
{
    enablePostProcessing(true);

    irr::video::E_MATERIAL_TYPE effectId= (irr::video::E_MATERIAL_TYPE)createMaterial(effectShader, callback);
    irr::video::CPostProcessingEffect* effect= new irr::video::CPostProcessingEffect(effectId, callback);
    RootPostProcessingEffectChain->attachEffect(effect);
    return effect;
}

irr::video::CPostProcessingEffect* irr::video::CRenderer::createPostProcessingEffect(irr::video::E_POSTPROCESSING_EFFECT type)
{
    video::CPostProcessingEffect* newEffect= 0;

    switch(type)
    {
        case EPE_ANTIALIASING:
            ShaderLib->loadShader("antialias", "quad.vert", "postprocess/antialias.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("antialias"));
            newEffect->addTextureToShader(getMRT(2)); //depth
            break;

        case EPE_BLOOM_PREPASS:
            ShaderLib->loadShader("bloom_prepass", "quad.vert", "postprocess/bloom_prepass.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("bloom_prepass"));
            break;

        case EPE_BLUR_V:
            ShaderLib->loadShader("blur_v", "quad.vert", "postprocess/blur_v.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("blur_v"));
            break;

        case EPE_BLUR_H:
            ShaderLib->loadShader("blur_h", "quad.vert", "postprocess/blur_h.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("blur_h"));
            break;

        case EPE_BLUR_H_ADD:
            ShaderLib->loadShader("blur_h_add", "quad.vert", "postprocess/blur_h_add.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("blur_h_add"));
            newEffect->addTextureToShader(getMRT(2)); //depth
            break;

        case EPE_COLD_COLORS:
            ShaderLib->loadShader("coldcolors", "quad.vert", "postprocess/coldcolors.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("coldcolors"));
            break;

        case EPE_WARM_COLORS:
            ShaderLib->loadShader("warmcolors", "quad.vert", "postprocess/warmcolors.frag");
            newEffect= createPostProcessingEffect(ShaderLib->getShader("warmcolors"));
            break;

        default: break; //this should never happen
    }

    return newEffect;
}

void irr::video::CRenderer::enablePostProcessing(bool enable, irr::video::ECOLOR_FORMAT format)
{
    if(enable && !LightMgr->getPostProcessingActive())
    {
        irr::core::dimension2du dimension= Device->getVideoDriver()->getCurrentRenderTargetSize();
        LightMgr->setPostProcessingTextures(Device->getVideoDriver()->addRenderTargetTexture(dimension, "Post-Processing-Tex1"),
                                            Device->getVideoDriver()->addRenderTargetTexture(dimension, "Post-Processing-Tex2"));
        LightMgr->setPostProcessingActive(true);
    }
    else if(!enable && LightMgr->getPostProcessingActive())
    {
        LightMgr->setPostProcessingActive(false);
        LightMgr->removePostProcessingTextures();
    }
}

irr::video::CPostProcessingEffectChain* irr::video::CRenderer::getRootPostProcessingEffectChain() const
{
    return RootPostProcessingEffectChain;
}


*******************************************************************************
        void setPostProcessingTextures(irr::video::ITexture* tex1, irr::video::ITexture* tex2);

        void removePostProcessingTextures();

        void setPostProcessingActive(bool active);

        bool getPostProcessingActive() const;

        void addPostProcessingEffectChain(irr::video::CPostProcessingEffectChain* chain);

        irr::u32 getActivePostProcessingEffectsCount() const;

        irr::u32 getActivePostProcessingEffectChainsCount() const;
===============================================================================
    //decide render targets
    if((getActivePostProcessingEffectsCount() == 0 || !getPostProcessingActive())
            && !getDoFinalRenderToTexture())
    {
        Device->getVideoDriver()->setRenderTarget(0);
    }
    else if(!getPostProcessingActive() && getDoFinalRenderToTexture())
    {
        Device->getVideoDriver()->setRenderTarget(FinalRender, true, true, 0);
    }
    else if(getPostProcessingActive())
    {
        for(irr::u32 i = 0; i < PostProcessingEffectChains.size(); i++)
        {
            irr::video::CPostProcessingEffectChain* chain = PostProcessingEffectChains[i];
            if(chain->isActive())
            {
                if(chain->getKeepOriginalRender())
                {
                    Device->getVideoDriver()->setRenderTarget(chain->getOriginalRender());
                    break;
                }
                else
                {
                    Device->getVideoDriver()->setRenderTarget(PPTex1, true, true, 0);
                    break;
                }
            }
        }
    }

    //post processing
    if(getPostProcessingActive() && getActivePostProcessingEffectsCount() > 0)
    {
        irr::u32 numTotalChains = PostProcessingEffectChains.size();
        irr::u32 numTotalEffects = getActivePostProcessingEffectsCount();
        irr::u32 numTotalEffectsDone = 0; // how many of the effects have we already rendered
        bool nextKeepOriginal = false; // true if next chain wishes to keep the original render

        for(irr::u32 i = 0; i < numTotalChains; i++)
        {
            if(PostProcessingEffectChains[i]->isActive())
            {
                irr::u32 numActiveEffects = PostProcessingEffectChains[i]->getActiveEffectCount();
                irr::u32 numEffectsDone = 0;

                for(irr::u32 j = 0; j < PostProcessingEffectChains[i]->getEffectCount(); j++)
                {
                    irr::video::CPostProcessingEffect* effect= PostProcessingEffectChains[i]->getEffectFromIndex(j);
                    if(effect->isActive())
                    {
                        //if this is the last effect, time to render to screen now (unless you want your last render done to texture)
                        if(numTotalEffectsDone+1 == numTotalEffects)
                        {
                            //if you want your last render directly to screen
                            if(!getDoFinalRenderToTexture()) Device->getVideoDriver()->setRenderTarget(0);
                            //if you want it to a render texture
                            else Device->getVideoDriver()->setRenderTarget(FinalRender);
                        }
                        // if not, set up stuff for "chained" post-processing
                        else
                        {
                            //maybe this is the last effect and the next chain wants to keep its original render? Then we have to render to a special texture inside the chain
                            irr::u32 nextChain = i + 1;
                            bool nextKeep = false;
                            if(numEffectsDone+1 == numActiveEffects)
                            {
                                if(nextChain < numTotalChains)
                                {

                                    if(PostProcessingEffectChains[nextChain]->getKeepOriginalRender() &&
                                            PostProcessingEffectChains[nextChain]->isActive())
                                    {
                                        nextKeep = true;
                                    }
                                }
                            }

                            if(nextKeep)
                            {
                                Device->getVideoDriver()->setRenderTarget(PostProcessingEffectChains[nextChain]->getOriginalRender());

                            }

                            //we better figure out which of the two alternating RTTs are we going to use
                            if(numTotalEffectsDone % 2 == 0)
                            {
                                if(!nextKeep)
                                {
                                    Device->getVideoDriver()->setRenderTarget(PPTex2);
                                }
                                LightQuad->setMaterialTexture(0, PPTex1);
                            }
                            else
                            {
                                if(!nextKeep)
                                {
                                    Device->getVideoDriver()->setRenderTarget(PPTex1);
                                }
                                LightQuad->setMaterialTexture(0, PPTex2);
                            }
                        }


                        for(irr::u32 k= 0; k < effect->getTextureToPassCount(); k++)
                        {
                            //1. channel is color, start from 2.
                            LightQuad->setMaterialTexture(k+1, effect->getTextureToPass(k));
                        }

                        LightQuad->setMaterialType(effect->getMaterialType());
                        LightQuad->render();

                        numTotalEffectsDone++;
                        numEffectsDone++;
                    }
                }
            }
        }
    }

void irr::scene::ILightManagerCustom::setPostProcessingTextures(irr::video::ITexture* tex1, irr::video::ITexture* tex2)
{
    PPTex1= tex1;
    PPTex2= tex2;
}

void irr::scene::ILightManagerCustom::removePostProcessingTextures()
{
    Device->getVideoDriver()->removeTexture(PPTex1);
    Device->getVideoDriver()->removeTexture(PPTex2);

    setPostProcessingActive(false);
}

void irr::scene::ILightManagerCustom::setPostProcessingActive(bool active)
{
    PostProcessing= active;
}

bool irr::scene::ILightManagerCustom::getPostProcessingActive() const
{
    return PostProcessing;
}

void irr::scene::ILightManagerCustom::addPostProcessingEffectChain(irr::video::CPostProcessingEffectChain* chain)
{
    PostProcessingEffectChains.push_back(chain);
}

irr::u32 irr::scene::ILightManagerCustom::getActivePostProcessingEffectsCount() const
{
    irr::u32 count= 0;
    for(irr::u32 i= 0; i < PostProcessingEffectChains.size(); i++)
    {
        if(PostProcessingEffectChains[i]->isActive())
        {
            count+= PostProcessingEffectChains[i]->getActiveEffectCount();
        }
    }
    return count;
}

irr::u32 irr::scene::ILightManagerCustom::getActivePostProcessingEffectChainsCount() const
{
    irr::u32 count= 0;
    for(irr::u32 i= 0; i < PostProcessingEffectChains.size(); i++)
    {
        if(PostProcessingEffectChains[i]->isActive()) count++;
    }
    return count;
}
